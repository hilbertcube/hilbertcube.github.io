<!DOCTYPE html>
<html lang="en">

<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-00W722FWP2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'G-00W722FWP2');
  </script>
  <title>Chladni Patterns, Part 2</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="subject" content='Vibration and standing waves'>
  <meta name="description" content="Describing Chladni patterns using the regular and biharmonic wave equations" />
  <meta name="keywords" content="Wave equation, python, eigenvalue,  boundary conditions" />
  <meta name="author" content="Don Le, ledongduu@gmail.com" />
  <meta name="format-detection" content="telephone=no"> <!-- Disable number string recognition-->
  <link rel="stylesheet" href="../../assets/css/main.css">
  <style>
    .front-img {
      display: block;
      width: 100%;
      border-radius: 10px;
      height: auto;
      margin: auto;
    }

    #circular-plate {
      width: 80%;
    }

    @media all and (max-width: 580px) {
      #circular-plate {
        width: 100%;
        margin: 0;
      }
    }

    .image-block {
      width: 65%;
    }

    #square-wave-table,
    #circle-wave-table {
      width: 80%;
    }
  </style>
</head>

<body class="nav-open light-mode">
  \[
  \newcommand{\lbrac}{\left(}
  \newcommand{\rbrac}{\right)}
  \]
  <nav class="navbar open" id="navbar">
    <!-- SIDE BAR -->
    <div id="logo"></div>
    <div class="side-nav-container"></div>
    <!--open attribute - default-->
    <div class="line-3"></div>
    <header class="major">
      <h2>Table of Contents</h2>
    </header> <!-- TABLE OF CONTENTS -->
    <div class="toc">
      <ul>
        <li><a href="#review-of-part-1">Review of Part 1</a></li>
        <li><a href="#generate-patterns">Generate Patterns in Python</a>
          <ul>
            <li><a href="#square-plate-code">Code for the Square Plate</a></li>
            <li><a href="#circular-plate-code">Code for the Circular Plate</a></li>
          </ul>
        </li>
        <li><a href="#results-and-analysis">Theoretical, Experimental Results and Data Analysis</a>
          <ul>
            <li><a href="#square-theoretical">Theoretical Results for the Square Plate</a></li>
            <li><a href="#square-analysis">Data Analysis for the Square Plate</a></li>
            <li><a href="#circular-theoretical">Theoretical Results for the Circular Plate</a></li>
            <li><a href="#circular-analysis">Data Analysis for the Circular Plate</a></li>
          </ul>
        </li>
        <li><a href="#References">References</a></li>
      </ul>
    </div>
    <div class="highlights-and-attribute"></div>
  </nav>

  <!--Master grid starts here -->
  <div class="content-grid">

    <!-- CONTENTS -->
    <div class="general-wrapper">


      <header>
        <div class="topic">
          Topics: Mathematics/Physics/Standing Waves/Python
        </div>
        <h1 class="title">
          The Quest to Finding Chladni Patterns, Part 2: Codes and Results
        </h1>
        <div class="date"></div>
        <figure style="margin: 0;">
          <img class="front-img" src="Chladni_patterns_2.webp">
        </figure>
        <div class="Quote">
          <div class="Quote-content">&#8220That there are such limits to our knowledge of nature, must be borne with
            patience by every sound mind whether he be a scientist or a workman.&#8221</div>
          <div class="Author">- Gustav Robert Kirchhoff</div>
        </div>
      </header>



      <section id="review-of-part-1">
        <h2>Review of Part 1</h2>
        <p>
          The previous part of this article talked about one of the theoretical models behind Chladni patterns: the wave
          equation model. We used this model to construct our contour equation and established two algorithms to plot
          the square model and the circular model. The square wave equation algorithm requires us to check if a number
          can be represented as a sum of squares. If it can be represented as sum(s) of squares, then we must search for
          all possible combinations of $n$ and $m$ such that
        </p>
        <div class="equation">
          \begin{equation}
          n^2 + m^2 = \mathrm{number}
          \end{equation}
        </div>
        <p>
          including pairs with zero. The circular wave equation model is simpler to implement, as we only need to
          utilize built-in integration methods, and do a double for loop to search over 0 to $n$ and 0 to $m$. Right
          below is the draft of the two algorithms that we have designed previously.
        </p>


        <div class="box" style="margin: 50px auto;">
          <div class="tab-button-container">
            <button class="tab-button tab-effect"
              onclick="changeTab(event, 'Square-Pseudo-Code', 'pseudo-tab')">Square</button>
            <button class="tab-button"
              onclick="changeTab(event, 'Circular-Pseudo-Code', 'pseudo-tab')">Circular</button>
          </div>

          <pre style="border-radius: 0px 7px 7px 7px;" id="Square-Pseudo-Code" class="pseudo-tab console">
    <samp># ALGORITHM 1: PLOT SQUARE CHLADNI PATTERNS
    
    # generate different sign combinations for X using 
    # an array of 1's and -1's.
    # always keep the first element positive (1)
    # return a list of list
    function generate_sign_combinations(pairs) 
        
    # define the basis function
    # we don't use Y(y), or m here because it's basically 
    # the exact same function as X
    function X(x, n)
        return mod(n + 1, 2) * cos(n * pi * x/ 2.0) + 
                mod(n, 2) * sin(n * pi * x/ 2.0)

    # plot the full wave function
    # input: x, y, pair (n, m) and sign array, for example, [1, -1, -1]
    function u(x, y, pairs, signs)

    # search for sum-of-squares pairs
    # find all pairs of (n, m) such that n^2 + m^2 = number
    # return value: a list of tuples (n, m) that satisfies the requirement
    function find_pairs(number) 

    # Check if a given number can be represented as sums of
    # squares pairs
    # return true if it is a sum of square
    function exist_sos(number) 

    # search for sum of squares
    # plot the sum of squares
    function plot_sum_of_squares(start_index, end_index)
</samp>
</pre>


          <pre style="border-radius: 0px 7px 7px 7px; display:none" id="Circular-Pseudo-Code"
            class="pseudo-tab console">
    <samp># ALGORITHM 2: PLOT CIRCULAR CHLADNI PATTERNS
        
    # Function to get the m-th zero of the derivative of the 
    # Bessel function of order n
    function bessel_derivative_zero(n, m):
        # redefine the first zero of J_0 prime to be 0
        # default is not zero for some reason
        if n == 0 then
            zeros = list(jnp_zeros(n, m + 1))
            zeros.insert(0, 0)
            return zeros[m]
        else
            # Get the m-th zero, treating first zero as the 
            # 0th zero
            return jnp_zeros(n, m + 1)[-1]  

    # Initial function f(r, theta)
    function f(r, theta):
        return r * np.cos(theta)

    # Two coefficients
    # use built-in integration tools to obtain these
    # input: pair (n, m), radius a
    function a_nm(n, m, a)   
    function b_nm(n, m, a)

    # Define the function J_n(z_nm * r / a) * (a_nm * cos(n*theta)
    # + b_nm * sin(n*theta))
    def u(n, m, r, theta, a)
        </samp>
</pre>
        </div>


        <p>
          In the next part, we will generate these patterns in Python, but before proceeding, remember to install Python
          (select install for all users) and download related dependencies by using the pip package manager:
        </p>

        <div style="text-align: center; margin: 25px 0;">
          <pre class="console" style="color: green;">
    <samp>    -m pip install matplotlib
        -m pip install numpy
        -m pip install itertools
        -m pip install scipy</samp>
</pre>
        </div>

        <p>
          In this article, we will use matplotlib to plot our coordinate systems, numpy for the mathematical functions
          and constants, itertools for convenient sign alternation tool, scipy for integration and built-in special
          functions.
        </p>
      </section>





      <h2>Generate Patterns in Python</h2>

      <section id="square-plate-code">
        <h3>Code for the Square Plate</h3>


        <p>
          Most of the code sketch that from the section above and the previous part is already pretty straight forward,
          but I want to make a few remarks about some of the functions used in this code snippet.
        </p>


        <div class="box" style="width: 80%; margin: 25px auto;">
          <div class="code-container">
            <button class="copy-btn">Copy</button>
            <pre><code class="language-python">def generate_sign_combinations(pairs):
    sign_combinations = list(itertools.product([1, -1], repeat=(len(pairs) - 1)))
    return [[1] + list(comb) for comb in sign_combinations]  # Keep the first sign positive        
        </code></pre>
          </div>
        </div>
        <p>
          The function <code class="inline-code">.product()</code> works similar to a cartesian product, or equivalent
          to a nested for-loop in the context of computer science. For example, <code
            class="inline-code">product('ABCD', repeat=2)</code> will output
        </p>

        <div style="text-align: center; margin: 25px 0;">
          <pre class="console"
            style="display:inline-block"><samp>  AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD </samp></pre>
        </div>

        <p>
          For our case, <code class="inline-code">.product([1, -1], repeat = (len(pairs) - 1))</code> will generate all
          possible combinations of 1 and -1 for a length of <code class="inline-code">len(pairs) - 1</code>. We need to
          use <code class="inline-code">len(pairs) - 1</code> because we want to keep the first sign positive, as seen
          in the return statement <code class="inline-code">[[1] + list(comb)]</code>. If <code
            class="inline-code">pairs = [(0, 5), (3, 4), (4, 3), (5, 0)]</code>, then <code
            class="inline-code">len(pairs) = 4</code>. We want to keep the first term to be positive, always, so <code
            class="inline-code">.product([1, -1], repeat = (len(pairs) - 1))</code> will generate
        </p>
        <div style="text-align: center; margin: 25px 0;">
          <pre class="console" style="display:inline-block"><samp>    [1, 1, 1] 
    [1, 1, -1]
    [1, -1, 1] 
    [1, -1, -1]    </samp></pre>
        </div>

        <p>
          The statement <code class="inline-code">sign_combinations = list(itertools.product([1, -1], repeat=(len(pairs)
            - 1)))</code> assigns a list of <code class="inline-code">[1, -1]</code> into <code
            class="inline-code">sign_combinations</code> up to <code class="inline-code">len(pairs) - 1</code>.
          The return statement <code class="inline-code">return [[1] + list(comb) for comb in sign_combinations]</code>
          returns a list of list, consisting of all combinations of 1 and -1. For the example above, if <code
            class="inline-code">len(pairs)</code> is 4, then the function will return
        </p>

        <div style="text-align: center; margin: 25px 0;">
          <pre class="console"
            style="display:inline-block"><samp>[ [1, 1, 1], [1, 1, -1], [1, 1, -1], [1, -1, -1] ]</samp></pre>
        </div>


        <p>
          The next function, $u(x, y, t)$, defined by
        </p>
        <div class="box" style="width: 80%; margin: 25px auto;">
          <div class="code-container">
            <button class="copy-btn">Copy</button>
            <pre><code class="language-python">def u(x, y, pairs, signs):
    equation = np.zeros_like(x)  # Return an array of 0's with the same type
    for (n, m), sign in zip(pairs, signs):
        equation += sign * X(x, n) * X(y, m)
    return equation        
        </code></pre>
          </div>
        </div>

        <p>
          takes in $x$, $y$, the pairs which we need to plots, and the signs list from the <code
            class="inline-code">generate_sign_combinations</code> function. The output is obviously the z-value of the
          function $u$. For example, if the pairs of $n$ and $m$ is given as <code class="inline-code">(n, m) = [[0, 5],
            [3, 4], [4, 3], [5, 0]]</code>, and the sign combinations is <code class="inline-code">[1, -1, -1]</code>,
          then the contour equation $u(x, y, t)$ must be
          <div class="equation">
            \begin{equation}
            u(x, y, t_0) = X(x, 0)X(y, 5) - X(x, 3)X(y, 4) - X(x, 4)X(y, 3) - X(x, 5)X(y, 0) = 0
            \end{equation}
          </div>
        </p>

        <p>
          The next function, <code class="inline-code">exist_sos(number)</code> is very straight-forward. It simply
          return true if a number can be represented as a sum of squares. Similarly, if a number is found, then the
          function <code class="inline-code">find_pairs(number)</code> find all such pairs, and then return all of them
          in a list.
        </p>

        <div class="box" style="width: 80%; margin: 25px auto;">
          <div class="code-container">
            <button class="copy-btn">Copy</button>
            <pre><code class="language-python">def find_pairs(number):
    return [(n, m) for n in range(0, int(np.sqrt(number)) + 1)
            for m in range(0, int(np.sqrt(number)) + 1) if n**2 + m**2 == number]
    return equation        
        </code></pre>
          </div>
        </div>

        <p>
          For example, if <code class="inline-code">number == 145</code>, then the pairs are <code
            class="inline-code">[(1, 12), (8, 9), (9, 8), (12, 1)]</code>. Most sum of squares numbers will have two or
          three pairs. Some have four like 145 or 25, but some number can have a quite large number of pairs. For
          example, if <code class="inline-code">number == 725</code>, then the pairs are <code class="inline-code">[(7,
            26), (10, 25), (14, 23), (23, 14), (25, 10), (26, 7)]</code>, or if <code class="inline-code">number ==
            9425</code>, then there are up to 12 pairs, <code class="inline-code">[(4, 97), (20, 95), (31, 92), (41,
            88), (55, 80), (64, 73), (73, 64), (80, 55), (88, 41), (92, 31), (95, 20), (97, 4)]</code>. This function is
          $O(n)$, which is pretty efficient. I think there is a way to make it even more efficient, but it lies beyond
          the scope of this article.
        </p>



        <p>
          The final, and longest function is the <code class="inline-code">plot_sum_of_squares(start_index,
            end_index)</code>. This function input the starting and ending pattern number, iterate through all patterns
          in between, and output them to the plots. We first focus on the first half of the function's code block and
          start by creating three lists: <code class="inline-code">equations</code>, <code
            class="inline-code">description</code>, and <code class="inline-code">sum_of_squares</code>.
        </p>
        <div class="box" style="width: 80%; margin: 25px auto;">
          <div class="code-container">
            <button class="copy-btn">Copy</button>
            <pre><code class="language-python">def plot_sum_of_squares(start_index, end_index):
    # ... something up here        
    
    equations = []
    descriptions = []
    sums_of_squares = []
        </code></pre>
          </div>
        </div>
        <p>
          The list <code class="inline-code">equations</code> stores all equations to plot, while the other two list are
          simply for documentation purposes. The list <code class="inline-code">sum_of_squares</code> is to store the
          sum-of-squares numbers, call it k, to output to the plot, while description store all pairs that made up that
          number and the signs combination to output to the terminal.
        </p>


        <p>
          The next part of the code is the while loop to iterate over all k to search for sum of squares. I want the
          user to be able to determine which index they want to start and end with to avoid overcrowding the screen with
          too much plot. Therefore, the <code class="inline-code">len(equations) < total_plots</code> is the breaking
              condition. </p> <div class="box" style="width: 80%; margin: 25px auto;">
              <div class="code-container">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-python">    # ...something up here
    k = 0
    found_plots = 0
    while len(equations) < total_plots:
        if exist_sos(k):
            # find all pairs from k
            pairs = find_pairs(k)                                   

            # find non zero pairs using slicing operator, copying element from second index of list, [1] 
            # to second to last element index of list, [-1]
            non_zero_pairs = pairs[1:-1]                            

            # generate a list of different sign combinations from pairs
            sign_combinations = generate_sign_combinations(pairs)  
            
            # iterates over each combination of signs produced in the previous step. 
            # for each combination, it will attempt to create an equation.
            for signs in sign_combinations:
                found_plots += 1

                # if the current found_plots is between start_index and end_index,
                # then append elements to lists
                # not all generated plots will be keptâ€”only those within this specific range.
                if start_index <= found_plots <= end_index:
                    equations.append((pairs, signs, u(x, y, pairs, signs)))
                    descriptions.append(f"{pairs} {signs}")
                    sums_of_squares.append(k)
                if found_plots >= end_index:
                    break

            # check if non_zero_pairs is not empty
            if non_zero_pairs:
                sign_combinations_0 = generate_sign_combinations(non_zero_pairs)
                for signs in sign_combinations_0:
                    found_plots += 1
                    if start_index <= found_plots <= end_index:
                        equations.append((non_zero_pairs, signs, u(x, y, non_zero_pairs, signs)))
                        descriptions.append(f"{non_zero_pairs} {signs}")
                        sums_of_squares.append(k)
                    if found_plots >= end_index:
                        break
            if found_plots >= end_index:
                break
        k += 1
        </code></pre>
              </div>
    </div>


    <p>
      The later half of the function is only to plot all graphs in the list. One technique for visibility of the plot is
      to assign colors to plots of the same modes, but different signs (different sign combinations of <code
        class="inline-code">[(1, 12), (8, 9), (9, 8), (12, 1)]</code> will have the same color, for example). Here,
      <code class="inline-code">pair_color_mapping</code> is a dictionary that maps each unique pair of values (<code
        class="inline-code">pairs_tuple</code>) to a color.
    </p>

    <div class="box" style="width: 80%; margin: 25px auto;">
      <div class="code-container">
        <button class="copy-btn">Copy</button>
        <pre><code class="language-python">    colors = ['darkblue', 'red', 'darkgreen', 'deeppink', 'darkviolet', 'blue', 'darkgoldenrod',
             'teal', 'darkred', 'darkcyan']
    pair_color_mapping = {}
    color_index = 0
        </code></pre>
      </div>
    </div>

    <p>
      And, there it is, our code for generating Chladni patterns on the square plate using the wave equations model and
      eigenvalues is completed. The full code is available right below. I added a few options for you to adjust based on
      your own preference.
    </p>

    <div class="box" style="margin-top: 30px; margin-bottom: 30px;">
      <div class="code-container">
        <button class="copy-btn">Copy</button>
        <pre class="line-numbers"><code class="language-python">import matplotlib.pyplot as plt
import numpy as np
import itertools

# Settings here
title = True
font_title = 9.2        # Title font size
color_plots = True      # All black or color plots
thickness = 1.2         # Plot line thickness
start = 1               # Start at pattern #
end = 72                # End at pattern #

# Range and step size
delta = 0.005
xrange = np.arange(-1.0, 1.0, delta)
yrange = np.arange(-1.0, 1.0, delta)
x, y = np.meshgrid(xrange, yrange)

# Define the basis function
def X(x, n):
    return np.mod(n + 1, 2) * np.cos(n * np.pi * x / 2.0) + np.mod(n, 2) * np.sin(n * np.pi * x / 2.0)

# Sign combination generator
def generate_sign_combinations(pairs):
    sign_combinations = list(itertools.product([1, -1], repeat=(len(pairs) - 1)))
    return [[1] + list(comb) for comb in sign_combinations]  # Keep the first sign positive

# The wave function with contour cut z = 0
def u(x, y, pairs, signs):
    equation = np.zeros_like(x)  # Return an array of 0's with the same type
    for (n, m), sign in zip(pairs, signs):
        equation += sign * X(x, n) * X(y, m)
    return equation

# Check if a given number has sums of squares pairs
def exist_sos(number):
    return any(n**2 + m**2 == number for n in range(0, int(np.sqrt(number)) + 1)
                for m in range(0, int(np.sqrt(number)) + 1))

# Searching combinations of sum of squares
def find_pairs(number):
    return [(n, m) for n in range(0, int(np.sqrt(number)) + 1)
            for m in range(0, int(np.sqrt(number)) + 1) if n**2 + m**2 == number]
    
plt.rcParams['mathtext.fontset'] = 'stix'
plt.rcParams['font.family'] = 'serif'

# Plot the sum of squares patterns from start_index to end_index (1-based indexing)
def plot_sum_of_squares(start_index, end_index):
    total_plots = end_index - start_index + 1
    
    # Error messages
    if end_index <= start_index:
        print("Error: End_index must be greater than start_index.\n")
        return
    if total_plots > 100:
        print("Error: Cannot plot more than 100 plots at a time.\n")
        return

    equations = []
    descriptions = []
    sums_of_squares = []
    
    # Iterating over all possible combinations
    k = 0
    found_plots = 0
    while len(equations) < total_plots:
        if exist_sos(k):
            pairs = find_pairs(k)
            non_zero_pairs = pairs[1:-1]
            sign_combinations = generate_sign_combinations(pairs)
            for signs in sign_combinations:
                found_plots += 1
                if start_index <= found_plots <= end_index:
                    equations.append((pairs, signs, u(x, y, pairs, signs)))
                    descriptions.append(f"{pairs} {signs}")
                    sums_of_squares.append(k)
                if found_plots >= end_index:
                    break
            if non_zero_pairs:
                sign_combinations_0 = generate_sign_combinations(non_zero_pairs)
                for signs in sign_combinations_0:
                    found_plots += 1
                    if start_index <= found_plots <= end_index:
                        equations.append((non_zero_pairs, signs, u(x, y, non_zero_pairs, signs)))
                        descriptions.append(f"{non_zero_pairs} {signs}")
                        sums_of_squares.append(k)
                    if found_plots >= end_index:
                        break
            if found_plots >= end_index:
                break
        k += 1

    ncols = 9  # Fixed number of columns
    nrows = (total_plots + ncols - 1) // ncols  # Calculate the number of rows (// = Floor division)
    
    # Define fig and axis
    fig, axs = plt.subplots(nrows, ncols, figsize=(1.2 * ncols, 4 * nrows))
    
    # Colors
    colors = ['darkblue', 'red', 'darkgreen', 'deeppink', 'darkviolet', 'blue', 'darkgoldenrod', 'teal', 'darkred', 'darkcyan']
    pair_color_mapping = {}
    color_index = 0
    
    # Plotting
    for i in range(total_plots):
        # Print all pairs and signs to the console
        print(f"N = {start + i} | S = {sums_of_squares[i]}: {descriptions[i]}")
        
        # pairs = equations[i][0], signs = equations[i][1], equation = equations[i][2]
        pairs, signs, equation = equations[i]
        pairs_tuple = tuple(pairs)
        if pairs_tuple not in pair_color_mapping:
            pair_color_mapping[pairs_tuple] = colors[color_index % len(colors)]
            color_index += 1
        
        mode_color = pair_color_mapping[pairs_tuple] if color_plots else 'black'
        row, col = divmod(i, ncols)
        plot_title = rf"$N = {start + i},\; S = {sums_of_squares[i]}$"
        
        ax = axs[row, col] if nrows > 1 else axs[col]
        ax.contour(x, y, equation, levels=[0], colors=mode_color, linewidths=thickness)
        
        if title:
            ax.set_title(plot_title, fontsize=font_title, ha='center', rotation='vertical', x=-0.1, y=0)
        ax.grid(True)
        ax.set_aspect('equal')
        ax.set_xticks([])
        ax.set_yticks([])
    
    plt.tight_layout()
    fig.subplots_adjust(hspace=0.2, wspace=0.1)
    plt.show()

# Plotting the sum of squares patterns for all perfect squares
plot_sum_of_squares(start, end)
        </code></pre>
      </div>
    </div>
    </section>




    <section id="circular-plate-code">
      <h3>Code for the Circular Plate</h3>

      <p>
        As mentioned earlier in this article, the circular plate is somewhat easier to implement, as it doesn't require
        searching for any sum-of-squares numbers. Each pair of $(n, m)$ is a pattern by itself, so we only need to make
        a double for loop to iterate over every single of of them. The first thing to do is to of course set up a
        function to find the m-th zero of the n-th derivative of the bessel function of the first kind, $J_n(x)$. For
        this, we must import <code class="inline-code">jn, jnp_zeros</code> from <code
          class="inline-code">scipy.special</code>
      </p>


      <div class="box" style="width: 80%; margin: 25px auto;">
        <div class="code-container">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-python"># Function to get the m-th zero of the derivative of the Bessel function of order n
def bessel_derivative_zero(n, m):
    if n == 0: #Redefine the first zero of J_0 prime to be 0
        zeros = list(jnp_zeros(n, m + 1))
        zeros.insert(0, 0)
        return zeros[m]
    else:
        return jnp_zeros(n, m + 1)[-1]  # Get the m-th zero, treating first zero as the 0th zero
        </code></pre>
        </div>
      </div>

      <p>
        One of the weird things about the <code class="inline-code">jnp_zeroes</code> is that it only output zeroes that
        are greater than zero, but zero itself is one of the zeroes of the derivative of the zeroth-order Bessel
        function, $J_0'(x)$. You can see this right in the figure below:
      </p>
      <figure>
        <img src="Bessel1st.webp" alt="" class="image-block">
        <figcaption>First few Bessel functions of the 1st kind.</figcaption>
      </figure>
      <p>
        As seen, $J_0(x)$ attains a maximum at $x=0$, hence $x=0$ is one of the zeroes of $J_0'(x)$. Therefore, we must
        add it to the list, and shift the rest of the zeroes by one unit. The next step in the algorithm is to calculate
        the coefficients $a_{nm}$ and $b_{nm}$,
      </p>
      <div class="equation">
        \begin{align}
        a_{nm} &= \frac{\langle J_0\cos(n\theta), f \rangle_w}{\langle J_0, J_0 \rangle_w} =
        \frac{\int_{0}^{a}\int_{0}^{2\pi}J_n\lbrac kr\rbrac\cos(n\theta)
        f(r,\theta)r\;drd\theta}{2\pi\int_{0}^{a}J_n^2\lbrac kr\rbrac rdr},\quad n, m = 0, 1, \ldots\\
        b_{nm} &= \frac{\langle J_0\sin(n\theta), f \rangle_w}{\langle J_0, J_0 \rangle_w} =
        \frac{\int_{0}^{a}\int_{0}^{2\pi}J_n\lbrac kr\rbrac\sin(n\theta)
        f(r,\theta)r\;drd\theta}{2\pi\int_{0}^{a}J_n^2\lbrac kr\rbrac rdr},\quad n, m = 0, 1, \ldots
        \end{align}
      </div>
      <p>
        We can do this using the built-in methods for double integration: <code
          class="inline-code">scipy.integrate</code>, <code class="inline-code">dblquad</code>:
      </p>

      <div class="box" style="width: 80%; margin: 25px auto;">
        <div class="code-container">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-python"># Define the double integrals for coefficients a_nm and b_nm
def a_nm(n, m, a):
    z_nm = bessel_derivative_zero(n, m)
    numerator = integrate.dblquad(lambda theta, r: jn(n, z_nm * r * 1.0/a) * np.cos(n * theta) * 
                        f(r, theta) * r, 0, a, lambda r: 0, lambda r: 2 * np.pi)[0]
    denominator = integrate.quad(lambda r: jn(n, z_nm * r * 1.0/a) ** 2 * r, 0, a)[0]
    return numerator / (2 * np.pi * denominator)

def b_nm(n, m, a):
    z_nm = bessel_derivative_zero(n, m)
    numerator = integrate.dblquad(lambda theta, r: jn(n, z_nm * r * 1.0/a) * np.sin(n * theta) * 
                        f(r, theta) * r, 0, a, lambda r: 0, lambda r: 2 * np.pi)[0]
    denominator = integrate.quad(lambda r: jn(n, z_nm * r * 1.0/a) ** 2 * r, 0, a)[0]
    return numerator / (2 * np.pi * denominator)
        </code></pre>
        </div>
      </div>

      <p>
        After calculating the coefficients, the final step is straight forward. Simply iterate through all $n$ and $m$
        using a double for loops and plot the figure.
      </p>


      <div class="box" style="width: 80%; margin: 30px auto;">
        <div class="code-container">
          <button class="copy-btn">Copy</button>
          <pre><code class="language-python"># Plotting function in polar coordinates
def plot_polar_contour(n_max, m_max, a, resolution=100):
    r = np.linspace(0, a, resolution)
    theta = np.linspace(0, 2 * np.pi, resolution)
    R, Theta = np.meshgrid(r, theta)
    
    if n_max < 1 or m_max < 1:
        print("Columns or lines cannot be less than 1\n")
        return

    # Define fig and axis
    fig, axs = plt.subplots(m_max, n_max, figsize=(1.4* n_max, 1.2 * m_max), subplot_kw=
            {'projection': 'polar'})
    
    for m in range(m_max):
        for n in range(n_max):
            Z = u(n, m, R, Theta, a)
            ax = axs[m, n] if m_max > 1 else axs[n]
            ax.contour(Theta, R, Z, levels=[0], colors=color, linewidths=thickness)
            ax.set_xticks([])
            ax.set_yticks([])
            ax.grid(False)
            
            plot_title = rf"$(n,m) = {n, m}$"
            if title:
                ax.set_title(plot_title, fontsize = 9, ha='center', rotation='vertical', 
                x=-0.1, y=0)

    plt.tight_layout()
    plt.show()

plot_polar_contour(columns, rows, a)
        </code></pre>
        </div>
      </div>


      <p>
        Put together all the pieces, and we may arrive at the final code for the circular plate, using the 2d wave
        equation to be:
      </p>

      <div class="box" style="margin: 30px auto;">
        <div class="code-container">
          <button class="copy-btn">Copy</button>
          <pre class="line-numbers"><code class="language-python">import matplotlib.pyplot as plt
import numpy as np
import scipy.integrate as integrate
from scipy.special import jn, jnp_zeros

a = 1.0                 # Radius of the plate
thickness = 1           # Line thickness
color = 'darkblue'      # Color
title = True            # Title?
columns = 7
rows = 5

# Function to get the m-th zero of the derivative of the Bessel function of order n
def bessel_derivative_zero(n, m):
    if n == 0: #Redefine the first zero of J_0 prime to be 0
        zeros = list(jnp_zeros(n, m + 1))
        zeros.insert(0, 0)
        return zeros[m]
    else:
        return jnp_zeros(n, m + 1)[-1]  # Get the m-th zero, treating first zero as the 0th zero


# Initial function f(r, theta)
def f(r, theta):
    return r * np.cos(theta)

# Define the double integrals for coefficients a_nm and b_nm
def a_nm(n, m, a):
    z_nm = bessel_derivative_zero(n, m)
    numerator = integrate.dblquad(lambda theta, r: jn(n, z_nm * r * 1.0/a) * np.cos(n * theta) * 
                        f(r, theta) * r, 0, a, lambda r: 0, lambda r: 2 * np.pi)[0]
    denominator = integrate.quad(lambda r: jn(n, z_nm * r * 1.0/a) ** 2 * r, 0, a)[0]
    return numerator / (2 * np.pi * denominator)

def b_nm(n, m, a):
    z_nm = bessel_derivative_zero(n, m)
    numerator = integrate.dblquad(lambda theta, r: jn(n, z_nm * r * 1.0/a) * np.sin(n * theta) * 
                        f(r, theta) * r, 0, a, lambda r: 0, lambda r: 2 * np.pi)[0]
    denominator = integrate.quad(lambda r: jn(n, z_nm * r * 1.0/a) ** 2 * r, 0, a)[0]
    return numerator / (2 * np.pi * denominator)

# Define the function J_n(z_nm * r / a) * (a_nm * cos(n*theta) + b_nm * sin(n*theta))
def u(n, m, r, theta, a):
    z_nm = bessel_derivative_zero(n, m)
    A_nm = a_nm(n, m, a)
    B_nm = b_nm(n, m, a)
    return jn(n, z_nm * r * 1.0/a) * (A_nm * np.cos(n * theta) + B_nm * np.sin(n * theta))

plt.rcParams['mathtext.fontset'] = 'stix'
plt.rcParams['font.family'] = 'serif'

# Plotting function in polar coordinates
def plot_polar_contour(n_max, m_max, a, resolution=100):
    r = np.linspace(0, a, resolution)
    theta = np.linspace(0, 2 * np.pi, resolution)
    R, Theta = np.meshgrid(r, theta)
    
    if n_max < 1 or m_max < 1:
        print("Columns or lines cannot be less than 1\n")
        return

    # Define fig and axis
    fig, axs = plt.subplots(m_max, n_max, figsize=(1.4* n_max, 1.2 * m_max), subplot_kw=
            {'projection': 'polar'})
    
    for m in range(m_max):
        for n in range(n_max):
            Z = u(n, m, R, Theta, a)
            ax = axs[m, n] if m_max > 1 else axs[n]
            ax.contour(Theta, R, Z, levels=[0], colors=color, linewidths=thickness)
            ax.set_xticks([])
            ax.set_yticks([])
            ax.grid(False)
            
            plot_title = rf"$(n,m) = {n, m}$"
            if title:
                ax.set_title(plot_title, fontsize = 9, ha='center', rotation='vertical', 
                x=-0.1, y=0)

    plt.tight_layout()
    plt.show()

plot_polar_contour(columns, rows, a)
        </code></pre>
        </div>
      </div>
      <!--box ends here-->
    </section>



    <h2>Theoretical, Experimental Results and Data Analysis</h2>

    <section id="square-theoretical">
      <h3>Theoretical Results for the Square Plate</h3>
      <p>
        In this section, we will compare our theoretical results from the codes to the experimental results from my
        experiment. The designed code above should be good for up and running. Before we proceed any further, there are
        a few things to note. The patterns displayed below is arranged so that the frequency increases from left to
        right, top to bottom. Each set of patterns of the same color correspond to a different node, with different sign
        combinations.
      </p>
      <p>
        The information about the modes and sign combinations is printed to the terminal. On each pattern's caption,
        there will be two numbers: $N=1$, which is simply the number of the pattern, and $S$, which is the sum of
        squares which that pattern is generated from (if $S=50$, then the modes are $(1, 7)$, $(5, 5)$ and $(7, 1)$,
        since $1^2+7^2=5^2 + 5^2=50$). By setting <code class="inline-code">start = 1</code> and <code
          class="inline-code">end = 72</code>, we shall obtain the patterns right below:
      </p>

      <figure>
        <img src="CSquare_1-72_1.webp" alt="" class="image-block" style="width: 70%">
        <figcaption>Pattern #1 to #72.</figcaption>
      </figure>

      <p>
        Furthermore, if you want more information about each pattern, open the terminal and the console of this output
        should generate something like this:
      </p>

      <div style="text-align: center; margin: 25px 0;">
        <pre class="console" style="display:inline-block"><samp>    N = 1 | S = 0: [(0, 0)] [1]
    N = 2 | S = 1: [(0, 1), (1, 0)] [1, 1]
    N = 3 | S = 1: [(0, 1), (1, 0)] [1, -1]
    N = 4 | S = 2: [(1, 1)] [1]
    N = 5 | S = 4: [(0, 2), (2, 0)] [1, 1] 
    N = 6 | S = 4: [(0, 2), (2, 0)] [1, -1]
    N = 7 | S = 5: [(1, 2), (2, 1)] [1, 1] 
    N = 8 | S = 5: [(1, 2), (2, 1)] [1, -1]
    N = 9 | S = 8: [(2, 2)] [1]
    N = 10 | S = 9: [(0, 3), (3, 0)] [1, 1] 
    N = 11 | S = 9: [(0, 3), (3, 0)] [1, -1]
    N = 12 | S = 10: [(1, 3), (3, 1)] [1, 1] 
    N = 13 | S = 10: [(1, 3), (3, 1)] [1, -1]
    N = 14 | S = 13: [(2, 3), (3, 2)] [1, 1]
    N = 15 | S = 13: [(2, 3), (3, 2)] [1, -1]
    ... and so on
</div>


    <p>If we continue to set <code class="inline-code">start = 73</code> and <code class="inline-code">end = 144</code>, we will obtain even more mesmerizing patterns like these:</p>
    <figure>
        <img src="CSquare_73-144_1.webp" alt="" class="image-block" style="width: 70%">
        <figcaption>Pattern #73 to #144.</figcaption>
    </figure>
    <p>and more, if we go further</p>
    <figure>
        <img src="CSquare_145-216_1.webp" alt="" class="image-block" style="width: 70%">
        <figcaption>Pattern #145 to #216.</figcaption>
    </figure>
    <p>and so much more,</p>
    <figure>
        <img src="CSquare_217-288_1.webp" alt="" class="image-block" style="width: 70%">
        <figcaption>Pattern #217 to #288..</figcaption>
    </figure>
    <p>
        There is no limit in how far you can go in a theoretical sense. But in reality, there will be no more new patterns after around $f= 5000$ Hz due to the amplitude of the plate being too small. After we are done with our theoretical result, we can compare these patterns with our actual experimental results. 
    </p>
    <p>
        For this project, I obtained the necessary equipment from my college's engineering stock room. Out of all the choices that we had, this experiment is probably the simplest to perform but quite challenging to explain and derive. If you are planning to conduct this experiment yourself, before conducting the experiment, remember to make sure that the surface on which we place our generator must be perfectly flat, or else the sand will be bouncing in a chaos manner. Wear ear plugs as well, since the plate will output some very loud noise if we are not at resonance frequency.
    </p>
    <p>
        Turn on the wave generator, put on the ear plugs, and these patterns will arise as we increases the frequency $f$.
    </p>
    <figure>
        <img src="Square1.webp" alt="" class="image-block" style="width: 70%">
        <figcaption>Experimental Results of the Square Plate.</figcaption>
    </figure>
</section>



<section id="square-analysis">
    <h3>Data Analysis of Square's Plate</h3>
    <p>
        The figure right below contains selected patterns that (relatively) matches with the patterns generated by our program. Note that some patterns are similar, while some other are not so much. I just pick that ones that are closest to our actual results.
    </p>
    <figure>
        <img class="image" id="circular-plate" src = "Similar_Square.webp">
        <figcaption class="caption">Matching patterns on the Square Plate.</figcaption>
    </figure>
    
    <figure>
        <img class="image" id="circular-plate" src = "Similar_Square_Theoretical.webp">
        <figcaption class="caption"> (Somewhat) similar patterns.</figcaption>
    </figure>

    <p>
        The modes and predicted wave speed of the patterns are listed in the table right below. Here, recall from the previous part that the wave speed is calculated by the formula
    </p>
    <div class="equation">
        \begin{equation} 
            c = \frac{2Lf}{\sqrt{n^2 + m^2}}.
        \end{equation}
    </div>
    <p>
        For this experiment, the length of our plate is $24.1\pm 0.1$ cm, and we are assuming that the thickness is negligible. For better organization, I made a table below, comparing the similar patterns obtained from the actual experiment and the patterns generated by the program. Each pattern has each own modes and sign-combination, so I also listed them in the table.
    </p>

    
    <div class="table-wrapper">
        
        <table style="margin-left: auto; margin-right: auto; text-align: center;" id="square-wave-table">
            <caption>Wave Speed of the Square Plate</caption>
            <tr style="border-top: 2px solid var(--grid-text-color); border-bottom: 1px solid var(--grid-text-color);">
                <th style="min-width: 80px"><strong>Pattern No. $(N)$</strong></th>
                <th><strong>Sum $(S)$</strong></th>
                <th><strong>Modes $(n,m)$</strong></th>
                <th><strong>Sign</strong></th>
                <th style="border-left: 1px solid var(--grid-text-color)"><strong>Found at</strong></th>
                <th><strong>Wave Speed</strong></th>
            </tr>
            <tr>
                <td>$21$</td>
                <td>$20$</td>
                <td>$(2, 4)\; (4, 2)\; $</td>
                <td>$[+, +]$</td>
                <td style="border-left: 1px solid var(--grid-text-color)">$245\pm 50$ Hz</td>
                <td>$26.41\pm 5.39$</td>
            </tr>
            <tr>
                <td>$17$</td>
                <td>$16$</td>
                <td>$(0, 4)\; (4, 0)\; $</td>
                <td>$[+, -]$</td>
                <td style="border-left: 1px solid var(--grid-text-color)">$453 \pm 50$ Hz</td>
                <td>$54.59\pm 6.03$</td>
            </tr>
            <tr>
                <td>$33$</td>
                <td>$26$</td>
                <td>$(1, 5)\; (5, 1)\; $</td>
                <td>$[+, -]$</td>
                <td style="border-left: 1px solid var(--grid-text-color)">$56 \pm 75$ Hz</td>
                <td>$53.41\pm 7.11$</td>
            </tr>
            <tr>
                <td>$22$</td>
                <td>$21$</td>
                <td>$(2, 4)\; (4, 2)\; $</td>
                <td>$[+, -]$</td>
                <td style="border-left: 1px solid var(--grid-text-color)">$647 \pm 75$ Hz</td>
                <td>$69.73\pm 8.09$</td>
            </tr>
            <tr>
                <td>$62$</td>
                <td>$58$</td>
                <td>$(3, 7)\; (7, 3)\; $</td>
                <td>$[+, -]$</td>
                <td style="border-left: 1px solid var(--grid-text-color)">$934 \pm 100$ Hz</td>
                <td>$59.11\pm 6.33$</td>
            </tr>
            <tr>
                <td>$52$</td>
                <td>$50$</td>
                <td>$(1, 7)\; (5, 5)\; (7, 1) $</td>
                <td>$[+, +, +]$</td>
                <td style="border-left: 1px solid var(--grid-text-color)">$2160 \pm 500$ Hz</td>
                <td>$147.24\pm 34.09$</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid-text-color)">
                <td>$223$</td>
                <td>$200$</td>
                <td>$(2, 14)\;(10, 10)\; (14, 2)\; $</td>
                <td>$[+, +, +]$</td>
                <td style="border-left: 1px solid var(--grid-text-color)">$3163 \pm 800$ Hz</td>
                <td>$107.80\pm 27.27$</td>
            </tr>
        </table>
    </div>

    <p>
        Based on the wave equation model that we used, the wave speed should remain a constant. This is not what we see here. The wave speed seems to increases as the frequency $f$ increases, and some results seem to fall off the increasing trend as well. Let's see what the circular plate has to offer.
    </p>
</section>
    
<section id="circular-theoretical">
    <h3>Theoretical Results for the Circular Plate</h3>
    <p>
        I did not set any start and end for the circular plate, simply because they all follow the same set of rules: the number of diameter lines increases as we further move to the right, and the number of rings increases as we move downward. Set <code class="inline-code">columns = 7</code> and <code class="inline-code">rows = 5</code> and our output will be generated as below. The computer-generated patterns for the circular plate a bit less interesting, and is not as versatile and mesmerizing as the square patterns.
    </p>
        <figure>
            <img src="CCircle1.webp" alt="" class="image-block" style="width: 70%">
            <figcaption>First 35 patterns of the Circular Plate.</figcaption>
        </figure>

    <p>
        On the other hand, our experimental results for the circular yield much more interesting outcome. I have yet to seen any diameter lines on any of my experiment, but our actual experimentation generates more patterns than just rings like our theoretical analysis.
    </p>

    <figure>
        <img src="Circle1.webp" alt="" class="image-block" style="width: 70%">
        <figcaption>Experimental Results of the Circular Plate.</figcaption>
    </figure>   
</section>


<section id="circular-analysis">
    <h3>Data Analysis of the Circular Plate</h3>

    <p>
        Similar to the square plate, the circular plate also has similar experimental patterns.
    </p>
        
    <figure>
        <img class="image" id="circular-plate" src = "Similar_Circle.webp">
        <figcaption class="caption">Matching patterns on the Circular Plate.</figcaption>
    </figure>

    <figure>
        <img class="image" id="circular-plate" src = "Similar_Circle_Theoretical.webp">
        <figcaption class="caption">Similar Patterns.</figcaption>
    </figure>

    <p>
        From the angular frequency of the plate from the previous part, we can easily derive the wave speed equation for the circular plate:
    </p>
    <div class="equation">
        \begin{equation} 
            c=\frac{2\pi f r}{z_{nm}}
        \end{equation}
    </div>
    <p>
        For our experiment, the plate's radius is $r = 12.1\pm 0.1$ cm.
    </p>
    <div class="table-wrapper">
        <table style="margin-left: auto; margin-right: auto; text-align: center;" id="circle-wave-table">
            <caption>Wave Speed of the Circular Plate</caption>
            <tr style="border-top: 2px solid var(--grid-text-color); border-bottom: 1px solid var(--grid-text-color);">
                <th><strong>Order $(n)$</strong></th>
                <th><strong>Zero ($m$)</strong></th>
                <th><strong>Zeroes of $J&#39;_n(r)$</strong></th>
                <th><strong>Found at</strong></th>
                <th><strong>Wave Speed ($m/s$)</strong></th>
            </tr>
            <tr>
                <td>$0$</td>
                <td>0</td>
                <td>$0.000000$</td>
                <td>$0.000$ Hz</td>
                <td>N/A</td>
            </tr>
            <tr>
                <td>$0$</td>
                <td>$1$</td>
                <td>$3.831706$</td>
                <td>$131 \pm 50$ Hz</td>
                <td>$25.885\pm 9.88$</td>
            </tr>
            <tr>
                <td>$0$</td>
                <td>$2$</td>
                <td>$7.0155867$</td>
                <td>$429 \pm 75$ Hz</td>
                <td>$46.298\pm 8.10$</td>
            </tr>
            <tr>
                <td>$0$</td>
                <td>$3$</td>
                <td>$10.1734681$</td>
                <td>$1079 \pm 100$ v</td>
                <td>$80.301\pm 14.05$</td>
            </tr>
            <tr>
                <td>$0$</td>
                <td>$4$</td>
                <td>$13.3236919$</td>
                <td>$1806 \pm 500$ Hz</td>
                <td>$102.627\pm 7.47$</td>
            </tr>
            <tr>
                <td>$0$</td>
                <td>$5$</td>
                <td>$16.4706301$</td>
                <td>$3320 \pm 750$ Hz</td>
                <td>$152.614\pm 34.50$</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid-text-color);">
                <td>$0$</td>
                <td>$6$</td>
                <td>$19.6158585$</td>
                <td>$4661 \pm 800$ Hz</td>
                <td>$172.184\pm 29.59$</td>
            </tr>
        </table>
    </div>

    <p>
        The wave speed of the circular plate also increases as the frequency $f$ increases, which is far from our expectation. What is going on here? Well, it turns out that the wave equation model might not be sufficient after all. The problem seems to be much more complicated than I expected, and we might need a much more precise model in order to accurately describe these patterns.
    </p>

    <div style="text-align: center;">
        <a style="text-align: center;" href="../the-quest-to-finding-chladni-patterns-3" class="redirect-button">
            Next
        </a>
    </div>

</section>




<section id = "References">
    <h2>References</h2>

    <ol class = "reference">
        <li>Linqi. Shao. Modeling a square vibrating plate. University of Waterloo, pages 1-58, 2018.</li>
        <li>Lord Rayleigh. Vibration of Plates, pages 352-361. Princeton University Press, New York, NY, 1894.</li>
        <li>John M. Davis. Introduction to Applied Partial Differential Equation. W. H. Freeman, New York City, 1st edition, 2012.</li>
        <li>Richard. Haberman. Applied Partial Differential Equations with Fourier Series and Boundary Value Problems. Pearson, New York City, 5th edition, 2018.</li>
        <li>Rudolph. Szilard. Theories and Applications of Plates Analysis. John Wiley and Sons, Inc., 111 River Street Hoboken, NJ 07030-5774, 2004</li>
        <li>Dispersion of flexural waves. <a href="https://www.acs.psu.edu/drussell/Demos/Dispersion/Flexural.html" class="url">https://www.acs.psu.edu/drussell/Demos/Dispersion/Flexural.html</a>, 2004. Accessed: 2024-05-26</li>
        <li>Thomas D. Rossing and Neville H. Fletcher. Two-Dimensional Systems: Membranes and Plates, pages 65-94. Springer New York, New York, 2004.</li>
        <li>Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Stable and accurate numerical methods for generalized kirchhoff-love plates, 2020. Accessed: 2024-05-26.
        </li>
    </ol>
</section>


<section>
  <h2>More Articles</h2>
  <div id="rec-article-container"></div>
</section>
            

        </div> <!--general wrapper ends here-->
    </div>
    <!--Master grid ends here -->

<div class="footer"></div>
<script src="../../assets/js/scripts.js"></script>
<script src="../../assets/js/blogpage-setting.js"></script>
<script>
    loadDate("chladni-2");
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript" id="MathJax-script" async></script>
</body>
</html>